# Alhorithms of Sort

Fast sort
--------
0. Выбрать элемент из массива. Назовём его опорным.
0. Разбиение: перераспределение элементов в массиве таким образом, что элементы меньше опорного помещаются перед ним, а больше или равные после.
0. Рекурсивно применить первые два шага к двум подмассивам слева и справа от опорного элемента. Рекурсия не применяется к массиву, в котором только один элемент или отсутствуют элементы.

![800px-Quicksort-diagram svg](https://user-images.githubusercontent.com/37710447/118929732-f513b400-b955-11eb-8e33-06513942c5ce.png)
- - - - - - -
Merge Sort
-------
0. Сортируемый массив разбивается на две части примерно одинакового размера;
0. Каждая из получившихся частей сортируется отдельно, например — тем же самым алгоритмом;
0. Два упорядоченных массива половинного размера соединяются в один.

![274px-Merge-sort-example-300px](https://user-images.githubusercontent.com/37710447/118929875-1f657180-b956-11eb-8cef-a68c9f33214a.gif)
- - - - - - -

Count Sort
-------
Находятся Min и Max
То насколько оно отличается от min и будет определять место в массиве, а последнее - max
- - - - - - - - -

Radix Sort
-------
Сравнение производится поразрядно: сначала сравниваются значения одного крайнего разряда, и элементы группируются по результатам этого сравнения, затем сравниваются значения следующего разряда, соседнего, и элементы либо упорядочиваются по результатам сравнения значений этого разряда внутри образованных на предыдущем проходе групп, либо переупорядочиваются в целом, но сохраняя относительный порядок, достигнутый при предыдущей сортировке. Затем аналогично делается для следующего разряда, и так до конца.
- - - - - - - - -

Gnome Sort
-------
Eсли мы хотим отсортировать массив с элементами [4, 2 ,7, 3] от большего к меньшему, то на итерациях цикла while будет происходить следующее:

* [4, 2 ,7, 3] (начальное состояние: i == 1, j == 2);
* [4, 2 ,7, 3] (ничего не произошло, но сейчас i == 2, j == 3);
* [4, 7 ,2, 3] (обмен a[2] и a[1], сейчас i == 1, а j == 3 по-прежнему);
* [7, 4, 2, 3] (обмен a[1] и a[0], сейчас i == 3, j == 4);
* [7, 4, 3, 2] (обмен a[3] и a[2], сейчас i == 2, j == 4);
* [7, 4, 2, 3] (ничего не произошло, но сейчас i == 4, j == 5);
цикл закончился, т. к. i не < 4.
- - - - - - - -

Сложность алгоритмов сортировки:
------
0. Алгоритмы сортировки O(n2) вроде сортировки вставками, пузырьком и выбором, которые используются в особых случаях;
0. Быстрая сортировка (общего назначения): в среднем O(n log n) обменов, но худшее время – O(n2), если массив уже отсортирован, или элементы равны;
0. Алгоритмы O(n log n), такие как сортировка слиянием и кучей (пирамидальная сортировка), которые также являются хорошими алгоритмами сортировки общего назначения;
O(n) или линейные алгоритмы сортировки (выбор, выбор с обменом, выбор с подсчетом) для списков целых чисел, которые могут быть подходящими в зависимости от характера целых чисел в ваших списках.
0. Поразрядная - O(w+n), где w - кол-во бит в разряде.
- - - - - - - - - - - - 

# Alhorithms of list
- - - - - - -
Списки
---------
Двусвязный
```    
    Node
    {
        Value { get; set; }
        Previous_Node { get; set; }
        Next_Node { get; set; }
    }
```
![image](https://user-images.githubusercontent.com/37710447/119268459-27e2d400-bc04-11eb-98df-7db8a9aec702.png)

- - - - - - - -
Кольцевой
```
    Node
    {
        Value { get; set; }
        Next_Node { get; set; }
    }
```
Next_Node на последнем эллементе ссылается на head   
![image](https://user-images.githubusercontent.com/37710447/119268465-30d3a580-bc04-11eb-916a-38de0b6f566b.png)

- - - - - - - -


Бинарное дерево
---------
```
        Node
        {
            LeftNode { get; set; }
            RightNode { get; set; }
            Value { get; set; }
        }
```
Они бывают разные
* двоичное древо поиска ![image](https://user-images.githubusercontent.com/37710447/119268592-bce5cd00-bc04-11eb-9c45-905e74a612a4.png)

* двоичная куча ![image](https://user-images.githubusercontent.com/37710447/119268557-89a33e00-bc04-11eb-8804-babf9dbdc42e.png)

- - - - - - - -


Матрица смежности
---------
обход в глубину:
![image](https://user-images.githubusercontent.com/37710447/119268097-71caba80-bc02-11eb-96df-4d5249ced190.png)
обход в ширину:
![image](https://user-images.githubusercontent.com/37710447/119268101-7a22f580-bc02-11eb-82ad-eaa1dfcf6d4e.png)



Список смежности => матрица смежности
* W[1] = [2, 3, 4] 
* W[2] = [1, 4, 5] 
* W[3] = [1, 4] 
* W[4] = [1, 2, 3, 5] 
* W[5] = [2, 4]
* array = [
            [0,1,1,1,0],
            [1,0,0,1,1],
            [1,0,0,1,0],
            [1,1,1,0,1],
            [0,1,0,1,0],
        ]
- - - - - - - - - -
Хеш-таблица
---------
Метод цепочек (открытое хеширование) — все элементы данных с совпадающем хешем объединяются в список.
![image](https://user-images.githubusercontent.com/37710447/119317200-e3e5e280-bc88-11eb-9d22-ded38e54d87e.png)

