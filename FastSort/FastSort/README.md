# Alhorithms of Sort

Fast sort
--------
0. Выбрать элемент из массива. Назовём его опорным.
0. Разбиение: перераспределение элементов в массиве таким образом, что элементы меньше опорного помещаются перед ним, а больше или равные после.
0. Рекурсивно применить первые два шага к двум подмассивам слева и справа от опорного элемента. Рекурсия не применяется к массиву, в котором только один элемент или отсутствуют элементы.

![800px-Quicksort-diagram svg](https://user-images.githubusercontent.com/37710447/118929732-f513b400-b955-11eb-8e33-06513942c5ce.png)
- - - - - - -
Merge Sort
-------
0. Сортируемый массив разбивается на две части примерно одинакового размера;
0. Каждая из получившихся частей сортируется отдельно, например — тем же самым алгоритмом;
0. Два упорядоченных массива половинного размера соединяются в один.

![274px-Merge-sort-example-300px](https://user-images.githubusercontent.com/37710447/118929875-1f657180-b956-11eb-8cef-a68c9f33214a.gif)
- - - - - - -

Count Sort
-------
Находятся Min и Max
То насколько оно отличается от min и будет определять место в массиве, а последнее - max
- - - - - - - - -

Radix Sort
-------
Сравнение производится поразрядно: сначала сравниваются значения одного крайнего разряда, и элементы группируются по результатам этого сравнения, затем сравниваются значения следующего разряда, соседнего, и элементы либо упорядочиваются по результатам сравнения значений этого разряда внутри образованных на предыдущем проходе групп, либо переупорядочиваются в целом, но сохраняя относительный порядок, достигнутый при предыдущей сортировке. Затем аналогично делается для следующего разряда, и так до конца.
- - - - - - - - -

Gnome Sort
-------
Eсли мы хотим отсортировать массив с элементами [4, 2 ,7, 3] от большего к меньшему, то на итерациях цикла while будет происходить следующее:

* [4, 2 ,7, 3] (начальное состояние: i == 1, j == 2);
* [4, 2 ,7, 3] (ничего не произошло, но сейчас i == 2, j == 3);
* [4, 7 ,2, 3] (обмен a[2] и a[1], сейчас i == 1, а j == 3 по-прежнему);
* [7, 4, 2, 3] (обмен a[1] и a[0], сейчас i == 3, j == 4);
* [7, 4, 3, 2] (обмен a[3] и a[2], сейчас i == 2, j == 4);
* [7, 4, 2, 3] (ничего не произошло, но сейчас i == 4, j == 5);
цикл закончился, т. к. i не < 4.
- - - - - - - -

Сложность алгоритмов сортировки:
------
0. Алгоритмы сортировки O(n2) вроде сортировки вставками, пузырьком и выбором, которые используются в особых случаях;
0. Быстрая сортировка (общего назначения): в среднем O(n log n) обменов, но худшее время – O(n2), если массив уже отсортирован, или элементы равны;
0. Алгоритмы O(n log n), такие как сортировка слиянием и кучей (пирамидальная сортировка), которые также являются хорошими алгоритмами сортировки общего назначения;
O(n) или линейные алгоритмы сортировки (выбор, выбор с обменом, выбор с подсчетом) для списков целых чисел, которые могут быть подходящими в зависимости от характера целых чисел в ваших списках.
0. Поразрядная - O(w+n), где w - кол-во бит в разряде.
